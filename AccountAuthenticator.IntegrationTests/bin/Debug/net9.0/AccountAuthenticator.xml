<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AccountAuthenticator</name>
    </assembly>
    <members>
        <member name="T:AccountAuthenticator.AccountInfo">
            <summary>
            Encapsulates Account Name, ApiKey, and Guid of the incoming request. 
            Smoother encapsulation for endpoints, just use this as a parameter and it 
            will collect the information for you, or appropriately throw errors. 
            </summary>
        </member>
        <member name="P:AccountAuthenticator.AccountInfo.AccountName">
            <summary>
            Account Name of the incoming request
            </summary>
        </member>
        <member name="P:AccountAuthenticator.AccountInfo.ApiKey">
            <summary>
            Api Key of the incoming request
            </summary>
        </member>
        <member name="P:AccountAuthenticator.AccountInfo.Guid">
            <summary>
            Guid of the incoming request
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AccountInfo.BindAsync(Microsoft.AspNetCore.Http.HttpContext,System.Reflection.ParameterInfo)">
            <summary>
            Is this even visible? I don't think so. 
            </summary>
        </member>
        <member name="T:AccountAuthenticator.AuthService">
            <summary>
            Service implementation to handle the database. Runs through Dapper.
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.#ctor(System.Data.IDbConnection)">
            <summary>
            Service implementation to handle the database. Runs through Dapper.
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.AddUser(System.String,System.String)">
            <summary>
            Adds a new user if one doesn't already exist and throws an error if they do. Should 
            only be used in the sign-up process.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:AccountAuthenticator.AuthService.NewSignIn(System.String)">
            <summary>
            Adds a new line to the API key table.
            </summary>
            <returns>API key</returns>
        </member>
        <member name="M:AccountAuthenticator.AuthService.GetAllUsers">
            <summary>
            <c>For Debug Only</c>, I wouldn't reccommend assigning this an endpoint. Returns all users sorted by 
            ID. 
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.GetUser(System.String)">
            <summary>
            Returns the user object from the given account. Throws an exception if the user does not exist.
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.IsValidApiKey(System.String,System.String)">
            <summary>
            You can decide whether or not the returned date is valid (if you want expiration dates). 
            Throws an exception if no API key exists in the table. 
            </summary>
            <param name="email">Email address used</param>
            <param name="key">API Key</param>
            <returns>Null or DateTime</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:AccountAuthenticator.AuthService.IsValidUserPass(System.String,System.String)">
            <summary>
            Returns True if the username and password match what's stored in the database. This 
            handles errors thrown by invalid users and simply returns False.
            </summary>
            <returns>If the hashed password equals the stored hash</returns>
        </member>
        <member name="M:AccountAuthenticator.AuthService.ReValidate(System.String,System.String)">
            <summary>
            Updates the api key with the current DateTime value. This allows recently 
            signed-in users to continue being signed in on their key. It's primarily 
            used by my IdentityMiddleware and not recommended you use it on its own.
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.UpdatePassword(System.String,System.String)">
            <summary>
            Updates the user's password in the table. Does not affect any of the API keys currently
            entered. 
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.UpdateRole(System.String,System.Int32)">
            <summary>
            Updates the user's role in the table. Does not affect any current keys.
            Does update the lookup dictionary with the new role. 
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.DeleteUser(System.String)">
            <summary>
            Deletes all sign-in records by the user and their place in the User table.
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.GlobalSignOut(System.String)">
            <summary>
            Signs a user out globally (all keys are deleted), such as in the instance 
            of someone else gaining access to their account.
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.KeySignOut(System.String,System.String)">
            <summary>
            Sign out on an individual device by passing the key you want signed out. 
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.ExpiredKeySignOut(System.TimeSpan)">
            <summary>
            Given the TimeSpan, remove keys from any user that are older than that length.
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.GetGuid(System.String)">
            <summary>
            Returns the Guid of a given account name. Has an internal dictionary to reduce 
            database calls and enable quick lookup.
            </summary>
        </member>
        <member name="M:AccountAuthenticator.AuthService.GetRole(System.String)">
            <summary>
            Returns the Role of a given account name. Has an internal dictionary to reduce database calls
            and enable quick lookups. 
            </summary>
        </member>
        <member name="T:AccountAuthenticator.IdentityMiddleware">
            <summary>
            Identity Middleware relies on the <c>IIDMiddlewareConfig</c> to be injected through DI, as well as the AuthService. 
            For any error, it will throw a <c>401</c> HTTP code with a string (of which 3 are user-friendly). Make sure 
            the headers always contain a little bit of information, as the 4th is developer-intended. 
            <br/> <br/>
            This takes every path not in Paths of the config and checks for email and API Key headers. If they are 
            null or empty, the response will give you the exact syntax. <br/>
            Afterwards, they will validate that you have a valid API key, and return a short, helpful message if not so. <br/>
            Finally, if the ExpirationDate is not null, it will calculate the time between. If it's over the expiration date, 
            it will remove that key. If it's under but over the re-auth time (also assuming config), it will 
            reset the expiration date. Then it will let the response pass. 
            </summary>
        </member>
        <member name="M:AccountAuthenticator.IdentityMiddleware.#ctor(Microsoft.AspNetCore.Http.RequestDelegate,AccountAuthenticator.AuthService,AccountAuthenticator.IDMiddlewareConfig)">
            <summary>
            Identity Middleware relies on the <c>IIDMiddlewareConfig</c> to be injected through DI, as well as the AuthService. 
            For any error, it will throw a <c>401</c> HTTP code with a string (of which 3 are user-friendly). Make sure 
            the headers always contain a little bit of information, as the 4th is developer-intended. 
            <br/> <br/>
            This takes every path not in Paths of the config and checks for email and API Key headers. If they are 
            null or empty, the response will give you the exact syntax. <br/>
            Afterwards, they will validate that you have a valid API key, and return a short, helpful message if not so. <br/>
            Finally, if the ExpirationDate is not null, it will calculate the time between. If it's over the expiration date, 
            it will remove that key. If it's under but over the re-auth time (also assuming config), it will 
            reset the expiration date. Then it will let the response pass. 
            </summary>
        </member>
        <member name="M:AccountAuthenticator.IdentityMiddleware.InvokeAsync(Microsoft.AspNetCore.Http.HttpContext)">
            <summary>
            
            </summary>
        </member>
        <member name="T:AccountAuthenticator.IdentityMiddlewareExtension">
            <summary>
            Unused XML comment
            </summary>
        </member>
        <member name="M:AccountAuthenticator.IdentityMiddlewareExtension.UseAccountIdentityMiddleware(Microsoft.AspNetCore.Builder.IApplicationBuilder,System.Action{AccountAuthenticator.IDMiddlewareConfig})">
            <summary>
            Enables the Identity Middleware for AccountAuthenticator. Create a lambda to configure options
            previously held in IIDMiddlewareConfig, with an example below.
            <code>
            app.UseAccountIdentityMiddleware(options => {
              options.Paths = ["/users", "/user", "/user/signin"];
              options.Whitelist = "/data";
              options.ExpirationDate = new TimeSpan(30, 0, 0, 0);
              options.ReValidationDate = new TimeSpan(5, 0, 0, 0);
            });
            </code>
            </summary>
        </member>
        <member name="T:AccountAuthenticator.IDMiddlewareConfig">
            <summary>
            Configure certain parts of your middleware, such as un-authenticated paths, and (optionally)
            the expiration dates of keys and when you want to re-validate their key for longer usage. 
            </summary>
        </member>
        <member name="P:AccountAuthenticator.IDMiddlewareConfig.Paths">
            <summary>
            Set to the list of paths you want the middleware (Identity Middleware) 
            to exclude authorization.
            </summary>
        </member>
        <member name="P:AccountAuthenticator.IDMiddlewareConfig.Whitelist">
            <summary>
            If not null, the middleware will only check paths that start with this 
            path. For example, in some projects, all API calls start with <c>/api</c>, so adding 
            that will only check paths that start with <c>/api</c>. 
            </summary>
        </member>
        <member name="P:AccountAuthenticator.IDMiddlewareConfig.ExpirationDate">
            <summary>
            Set to the timespan that API keys are valid for. <c>Null</c> enables no time validation 
            (not recommended). 
            </summary>
        </member>
        <member name="P:AccountAuthenticator.IDMiddlewareConfig.ReValidationDate">
            <summary>
            If set to <c>null</c>, does nothing. Otherwise, set it to a timespan so if their key is still 
            valid, reset the expiration date for their API key. 
            </summary>
        </member>
        <member name="T:AccountAuthenticator.StringHelper">
            <summary>
            Provides a few custom methods for working with random strings (perhaps could be named better). 
            Used in my Authentication libraries. 
            </summary>
        </member>
        <member name="M:AccountAuthenticator.StringHelper.CustomHash(System.String)">
            <summary>
            Runs the given string through the SHA256 encoding and converts it out through 
            Base 64. "Simple" hash.
            </summary>
            <returns>Hashed string</returns>
        </member>
        <member name="M:AccountAuthenticator.StringHelper.GenerateRandomString(System.Int32)">
            <summary>
            Generates a random string of alphanumeric characters with the given length. Includes uppercase, 
            lowercase, numbers, !, and _. 
            </summary>
        </member>
    </members>
</doc>
